/*
 * i2c.h
 *
 * Работа с шиной I2C
 *
 * Сама шина хорошо описана тут:
 * http://easyelectronics.ru/interface-bus-iic-i2c.html
 *
 * Описание модуля I2C микроконтроллеров AVR в переведенном даташите - тут
 * http://www.gaw.ru/html.cgi/txt/doc/micros/avr/arh128/18.htm
 *
 */

#ifndef I2C_H_
#define I2C_H_

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>


// Дескриптор шины с её настройками
typedef struct
{
	uint32_t f_scl; // частота линии SCL I2C шины
	uint32_t timeout_us; // таймаут на I2C операции в микросекундах
} rscs_i2c_bus_t;


// Ошибки шины I2C
typedef enum {
	I2C_wrong_status = -1,   // Получен не верный статус в результате операции.
	I2C_timeout = -2,		 // Операция I2C не уложилась в заданное время
	I2C_arb_lost = -3,
	I2C_nack_recivied = -4,
} i2c_error_t;



// Инициализация i2c.
void rscs_i2c_bus_init(rscs_i2c_bus_t * bus);

// Сброс модуля I2C. Полезно при повторном запуске после обнаружения ошибки
// рекомендуется делать перед первым стартом сесии обмена данными
void rscs_i2c_reset(rscs_i2c_bus_t * bus);

// Создает на i2c шине событие START.
/*
 Если шина и так находится под нашим контролем - этот вызов создаст событие RESTART
 Возвращает 0 если все в порядке и не ноль в случае ошибки
*/
int rscs_i2c_start(rscs_i2c_bus_t * bus);

// Создает на шине состояние STOP
/* Если возвращает не 0 - что-то пошло не так */
int rscs_i2c_stop(rscs_i2c_bus_t * bus);

// Отправляет на шину 7мибитный адрес ведомого устройства с битом-флагом чтения/записи
/*
 Второй пареметр == 0 - обращение к ведомому в режиме записи.
 Второй параметр == 1 - обращение к ведомому в режиме чтения.
 Возвращает 0 если все в порядке и не ноль в случае ошибки
*/
int rscs_i2c_send_slaw(rscs_i2c_bus_t * bus, uint8_t slave_addr, bool read_access);

// Передача данных ведомому устройству
/*
 Перед вызовом этой функции на шину нужно передать адрес ведомого без бита чтения - `i2c_send_slaw(..., 0);`

 Записывает data_size байт из памяти по указателю data_ptr на устройство.
 Возвращает 0 если все в порядке и uint8_t slave_addr в случае если адресс
 ведомого  (без бита чт/зп) не отправился.
*/
int rscs_i2c_write(rscs_i2c_bus_t * bus, const void * data_ptr, size_t data_size);


// Получение данных от ведомого устройства
/*
 Перед вызовом этой функции на шину нужно передать адрес ведомого без бита чтения - `i2c_send_slaw(..., 0);`

 Получает data_size байт от ведомого устройства и записывает по указанному указателю data_ptr.
 аргумент NACK_at_end позволяет управлять подтверждением получения байта от ведомого.
 если этот аргумент установлен в true, то после получения последнего байта ведомому будет передан
 Not ACKnowledge, что означает завершение сеанса чтения.
 Возвращает 0 если все в порядке
*/
int rscs_i2c_read(rscs_i2c_bus_t * bus, void * data_ptr, size_t data_size, bool NACK_at_end);

#endif /* I2C_H_ */
